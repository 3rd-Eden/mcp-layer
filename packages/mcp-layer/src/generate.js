import { access, readFile, readdir, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { LayerError } from '@mcp-layer/error';

/**
 * Convert a package folder name into a namespace export name.
 * @param {string} name - Package folder name.
 * @returns {string} Namespace export name.
 */
export function toNamespace(name) {
  return name.replace(/-([a-z0-9])/g, function toCamel(_, next) {
    return next.toUpperCase();
  });
}

/**
 * Collect package folder names from the workspace packages directory.
 * @param {string} rootDir - Repository root directory.
 * @returns {Promise<string[]>} Package folder names.
 */
export async function collectPackages(rootDir) {
  const packagesDir = path.join(rootDir, 'packages');
  const entries = await readdir(packagesDir, { withFileTypes: true });
  const packages = [];

  for (const entry of entries) {
    if (!entry.isDirectory()) continue;

    const pkgPath = path.join(packagesDir, entry.name, 'package.json');
    const exists = await hasPackageJson(pkgPath);

    if (exists) packages.push(entry.name);
  }

  packages.sort();
  return packages;
}

/**
 * Check whether a package.json exists for the given path.
 * @param {string} pkgPath - Expected package.json path.
 * @returns {Promise<boolean>} Whether the package.json exists.
 */
export async function hasPackageJson(pkgPath) {
  try {
    await access(pkgPath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Build the root index.js content from workspace packages.
 * @param {string} rootDir - Repository root directory.
 * @returns {Promise<string>} Generated index.js content.
 */
export async function buildIndex(rootDir, selfName = 'mcp-layer') {
  const meta = await collectPackageMeta(rootDir, new Set([selfName]));
  const lines = [];

  lines.push('/**');
  lines.push(' * @module mcp-layer');
  lines.push(' * @description Aggregate entrypoint for the MCP Layer workspace packages.');
  lines.push(' * @note This file is autogenerated by src/generate.js. Manual edits will be overwritten.');
  lines.push(' */');
  lines.push('');

  for (const item of meta) {
    const namespace = toNamespace(item.dir);
    const importPath = item.name;

    lines.push('/**');
    lines.push(` * Package namespace from \`${item.name}\`.`);
    lines.push(` * @type {typeof import('${importPath}')}`);
    lines.push(' */');
    lines.push(`export * as ${namespace} from '${importPath}';`);
    lines.push('');
  }

  return `${lines.join('\n')}\n`;
}

/**
 * Collect package metadata from workspace folders.
 * @param {string} rootDir - Repository root directory.
 * @param {Set<string>} omit - Package names to skip.
 * @returns {Promise<Array<{name: string, dir: string}>>} Package metadata.
 */
export async function collectPackageMeta(rootDir, omit = new Set()) {
  const packages = await collectPackages(rootDir);
  const meta = [];

  for (const dir of packages) {
    const pkgPath = path.join(rootDir, 'packages', dir, 'package.json');
    const data = await readJson(pkgPath);
    if (omit.has(data.name)) continue;
    meta.push({ name: data.name, dir });
  }

  return meta;
}

/**
 * Update mcp-layer package dependencies to match workspace packages.
 * @param {string} pkgDir - mcp-layer package directory.
 * @param {string} rootDir - Repository root directory.
 * @param {string} selfName - mcp-layer package name.
 * @returns {Promise<void>} Resolves when dependencies are updated.
 */
export async function syncDependencies(pkgDir, rootDir, selfName = 'mcp-layer') {
  const pkgPath = path.join(pkgDir, 'package.json');
  const data = await readJson(pkgPath);
  const deps = { ...(data.dependencies ?? {}) };
  const meta = await collectPackageMeta(rootDir, new Set([selfName]));
  const names = new Set();

  for (const item of meta) {
    if (!item.name.startsWith('@mcp-layer/')) continue;
    names.add(item.name);
    deps[item.name] = 'workspace:*';
  }

  for (const key of Object.keys(deps)) {
    if (key.startsWith('@mcp-layer/') && !names.has(key)) delete deps[key];
  }

  data.dependencies = sortObject(deps);
  await writeJson(pkgPath, data);
}

/**
 * Write the generated index.js file if contents differ.
 * @param {string} rootDir - Repository root directory.
 * @param {string} outFile - Output file path.
 * @returns {Promise<void>} Resolves when the file is written or unchanged.
 */
export async function writeIndex(rootDir, outFile, selfName = 'mcp-layer') {
  const next = await buildIndex(rootDir, selfName);
  const current = await readMaybe(outFile);

  if (current === next) return;

  await writeFile(outFile, next, 'utf8');
}

/**
 * Read a file if it exists, otherwise return null.
 * @param {string} filePath - File path to read.
 * @returns {Promise<string | null>} File contents or null.
 */
export async function readMaybe(filePath) {
  try {
    return await readFile(filePath, 'utf8');
  } catch {
    return null;
  }
}

/**
 * Read and parse a JSON file.
 * @param {string} filePath - JSON file path.
 * @returns {Promise<Record<string, any>>} Parsed JSON data.
 */
export async function readJson(filePath) {
  const raw = await readFile(filePath, 'utf8');
  return JSON.parse(raw);
}

/**
 * Write a JSON file with stable formatting.
 * @param {string} filePath - JSON file path.
 * @param {Record<string, any>} data - JSON data to write.
 * @returns {Promise<void>} Resolves when the file is written.
 */
export async function writeJson(filePath, data) {
  const next = `${JSON.stringify(data, null, 2)}\n`;
  const current = await readMaybe(filePath);

  if (current === next) return;

  await writeFile(filePath, next, 'utf8');
}

/**
 * Sort an object's keys alphabetically.
 * @param {Record<string, string>} input - Object to sort.
 * @returns {Record<string, string>} Sorted object.
 */
export function sortObject(input) {
  const keys = Object.keys(input).sort();
  const sorted = {};

  for (const key of keys) {
    sorted[key] = input[key];
  }

  return sorted;
}

/**
 * Find the workspace root directory by locating pnpm-workspace.yaml.
 * @param {string} start - Directory to start searching from.
 * @returns {Promise<string>} Workspace root directory.
 */
export async function findWorkspaceRoot(start) {
  let current = path.resolve(start);

  while (true) {
    const marker = path.join(current, 'pnpm-workspace.yaml');
    if (await hasPackageJson(marker)) return current;

    const parent = path.dirname(current);
    if (parent === current)
      throw new LayerError({
        name: 'mcp-layer',
        method: 'findWorkspaceRoot',
        message: 'Unable to locate workspace root from mcp-layer package.',
      });

    current = parent;
  }
}

/**
 * Run the generator when executed as a script.
 * @returns {Promise<void>} Resolves when generation completes.
 */
export async function run() {
  const fileDir = path.dirname(fileURLToPath(import.meta.url));
  const pkgDir = path.resolve(fileDir, '..');
  const rootDir = await findWorkspaceRoot(pkgDir);
  const outFile = path.join(pkgDir, 'src', 'index.js');
  const data = await readJson(path.join(pkgDir, 'package.json'));

  await syncDependencies(pkgDir, rootDir, data.name);
  await writeIndex(rootDir, outFile, data.name);
}

const entry = fileURLToPath(import.meta.url);
if (process.argv[1] === entry) run();
