import { access, readFile, readdir, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

/**
 * Convert a package folder name into a namespace export name.
 * @param {string} name - Package folder name.
 * @returns {string} Namespace export name.
 */
export function toNamespace(name) {
  return name.replace(/-([a-z0-9])/g, function toCamel(_, next) {
    return next.toUpperCase();
  });
}

/**
 * Collect package folder names from the workspace packages directory.
 * @param {string} rootDir - Repository root directory.
 * @returns {Promise<string[]>} Package folder names.
 */
export async function collectPackages(rootDir) {
  const packagesDir = path.join(rootDir, 'packages');
  const entries = await readdir(packagesDir, { withFileTypes: true });
  const packages = [];

  for (const entry of entries) {
    if (!entry.isDirectory()) {
      continue;
    }

    const pkgPath = path.join(packagesDir, entry.name, 'package.json');
    const exists = await hasPackageJson(pkgPath);

    if (exists) {
      packages.push(entry.name);
    }
  }

  packages.sort();
  return packages;
}

/**
 * Check whether a package.json exists for the given path.
 * @param {string} pkgPath - Expected package.json path.
 * @returns {Promise<boolean>} Whether the package.json exists.
 */
export async function hasPackageJson(pkgPath) {
  try {
    await access(pkgPath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Build the root index.js content from workspace packages.
 * @param {string} rootDir - Repository root directory.
 * @returns {Promise<string>} Generated index.js content.
 */
export async function buildIndex(rootDir) {
  const meta = await collectPackageMeta(rootDir);
  const lines = [];

  lines.push('/**');
  lines.push(' * @module mcp-layer');
  lines.push(' * @description Aggregate entrypoint for the MCP Layer workspace packages.');
  lines.push(' * @note This file is autogenerated by src/generate.js. Manual edits will be overwritten.');
  lines.push(' */');
  lines.push('');

  for (const item of meta) {
    const namespace = toNamespace(item.dir);
    const importPath = item.name;

    lines.push('/**');
    lines.push(` * Package namespace from \`${item.name}\`.`);
    lines.push(` * @type {typeof import('${importPath}')}`);
    lines.push(' */');
    lines.push(`export * as ${namespace} from '${importPath}';`);
    lines.push('');
  }

  return `${lines.join('\n')}\n`;
}

/**
 * Collect package metadata from workspace folders.
 * @param {string} rootDir - Repository root directory.
 * @returns {Promise<Array<{name: string, dir: string}>>} Package metadata.
 */
export async function collectPackageMeta(rootDir) {
  const packages = await collectPackages(rootDir);
  const meta = [];

  for (const dir of packages) {
    const pkgPath = path.join(rootDir, 'packages', dir, 'package.json');
    const data = await readJson(pkgPath);
    meta.push({ name: data.name, dir });
  }

  return meta;
}

/**
 * Update root package.json dependencies to match workspace packages.
 * @param {string} rootDir - Repository root directory.
 * @returns {Promise<void>} Resolves when dependencies are updated.
 */
export async function syncDependencies(rootDir) {
  const pkgPath = path.join(rootDir, 'package.json');
  const data = await readJson(pkgPath);
  const deps = { ...(data.dependencies ?? {}) };
  const meta = await collectPackageMeta(rootDir);
  const names = new Set();

  for (const item of meta) {
    names.add(item.name);
    deps[item.name] = 'workspace:*';
  }

  for (const key of Object.keys(deps)) {
    if (key.startsWith('@mcp-layer/') && !names.has(key)) {
      delete deps[key];
    }
  }

  data.dependencies = sortObject(deps);
  await writeJson(pkgPath, data);
}

/**
 * Write the generated index.js file if contents differ.
 * @param {string} rootDir - Repository root directory.
 * @param {string} outFile - Output file path.
 * @returns {Promise<void>} Resolves when the file is written or unchanged.
 */
export async function writeIndex(rootDir, outFile) {
  const next = await buildIndex(rootDir);
  const current = await readMaybe(outFile);

  if (current === next) {
    return;
  }

  await writeFile(outFile, next, 'utf8');
}

/**
 * Read a file if it exists, otherwise return null.
 * @param {string} filePath - File path to read.
 * @returns {Promise<string | null>} File contents or null.
 */
export async function readMaybe(filePath) {
  try {
    return await readFile(filePath, 'utf8');
  } catch {
    return null;
  }
}

/**
 * Read and parse a JSON file.
 * @param {string} filePath - JSON file path.
 * @returns {Promise<Record<string, any>>} Parsed JSON data.
 */
export async function readJson(filePath) {
  const raw = await readFile(filePath, 'utf8');
  return JSON.parse(raw);
}

/**
 * Write a JSON file with stable formatting.
 * @param {string} filePath - JSON file path.
 * @param {Record<string, any>} data - JSON data to write.
 * @returns {Promise<void>} Resolves when the file is written.
 */
export async function writeJson(filePath, data) {
  const next = `${JSON.stringify(data, null, 2)}\n`;
  const current = await readMaybe(filePath);

  if (current === next) {
    return;
  }

  await writeFile(filePath, next, 'utf8');
}

/**
 * Sort an object's keys alphabetically.
 * @param {Record<string, string>} input - Object to sort.
 * @returns {Record<string, string>} Sorted object.
 */
export function sortObject(input) {
  const keys = Object.keys(input).sort();
  const sorted = {};

  for (const key of keys) {
    sorted[key] = input[key];
  }

  return sorted;
}

/**
 * Run the generator when executed as a script.
 * @returns {Promise<void>} Resolves when generation completes.
 */
export async function run() {
  const rootDir = process.cwd();
  const outFile = path.join(rootDir, 'src', 'index.js');

  await syncDependencies(rootDir);
  await writeIndex(rootDir, outFile);
}

const entry = fileURLToPath(import.meta.url);
if (process.argv[1] === entry) {
  run();
}
